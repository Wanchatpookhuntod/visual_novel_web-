<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flowchart Editor</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
            background-color: #f0f0f0;
        }

        #addNodeButton {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 10;
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
        }

        #nodeForm {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 5px;
            z-index: 20;
        }

        #nodeForm input {
            display: block;
            margin-bottom: 10px;
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            font-family: Verdana, Geneva, Tahoma, sans-serif;
        }

        #nodeForm button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: block;
            margin: 0 auto;
            margin-top: 10px;
        }

        #nodeForm textarea {
            display: block;
            margin-bottom: 10px;
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            min-height: min-content;
            font-family: Verdana, Geneva, Tahoma, sans-serif;
            min-width: 100%;
            font-size: 12px;

        }

        #btnForm button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: block;
            margin: 0 auto;
            margin: 10px;
        }


        .container {
            display: grid;
            grid-template-columns: 30% 70%;
            /* background-color: dodgerblue; */
            background-color: #f7f7f7;
            border: 1px solid #e3e3e3;
            border-radius: 3px;
        }

        .container>div {
            padding: 2px;
            padding-left: 3px;
            padding-right: 3px;
            font-size: 16px;
            display: flex;
            align-items: center;
            height: 100%;
        }
    </style>
</head>

<body>
    <div style="display: flex; justify-content: center; align-items: center; height: 100vh;">
        <canvas id="flowchartCanvas"></canvas>
    </div>
    <button id="addNodeButton">Add Node</button>
    <div id="nodeForm">
        <input type="text" id="nodeTitle" style="border: 1px solid rgb(201, 201, 201); border-radius: 3px;"
            placeholder="Node Title">

        <div id="adTextForm"></div>

        <div id="btnForm" style="display: flex; justify-content: space-between;">
            <button id="saveNodeButton">Save Node</button>
            <button id="addTextButton">Add Text</button>
        </div>
    </div>

    <script>
        let allNodeValue = {};

        const canvas = document.getElementById("flowchartCanvas");
        const ctx = canvas.getContext("2d");

        const scale = window.devicePixelRatio;
        canvas.width = (window.innerWidth - 20) * scale;
        canvas.height = (window.innerHeight - 20) * scale;
        canvas.style.width = `${window.innerWidth - 20}px`;
        canvas.style.height = `${window.innerHeight - 20}px`;
        ctx.scale(scale, scale);

        let nodes = [
            { x: 100, y: 100, width: 80, height: 50, id: 1, title: "Node 1" },
            { x: 300, y: 200, width: 80, height: 50, id: 2, title: "Node 2" },
            { x: 500, y: 100, width: 80, height: 50, id: 3, title: "Node 3" }
        ];
        let connections = [];
        let selectedOutput = null;
        let tempConnection = null;
        let isDragging = false;
        let selectedNode = null;

        function drawRoundedRect(x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fillStyle = "white";
            ctx.fill();
            ctx.strokeStyle = "#ccc";
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            connections.forEach(({ from, to }) => {
                ctx.beginPath();
                ctx.moveTo(from.x + from.width + 10, from.y + from.height / 2);
                ctx.lineTo(to.x - 10, to.y + to.height / 2);
                ctx.strokeStyle = "black";
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            if (tempConnection) {
                ctx.beginPath();
                ctx.moveTo(tempConnection.x, tempConnection.y);
                ctx.lineTo(tempConnection.endX, tempConnection.endY);
                ctx.strokeStyle = "gray";
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            nodes.forEach(node => {
                drawRoundedRect(node.x, node.y, node.width, node.height, 5);
                ctx.fillStyle = "black";
                ctx.font = "bold 14px Arial";
                ctx.fillText(node.title, node.x + 10, node.y + node.height / 2 + 5);

                ctx.beginPath();
                ctx.arc(node.x - 10, node.y + node.height / 2, 7, 0, Math.PI * 2);
                ctx.fillStyle = "red";
                ctx.fill();

                ctx.beginPath();
                ctx.arc(node.x + node.width + 10, node.y + node.height / 2, 7, 0, Math.PI * 2);
                ctx.fillStyle = "green";
                ctx.fill();
            });
        }

        draw();

        function getOutputAt(x, y) {
            return nodes.find(node => {
                const dx = x - (node.x + node.width + 10);
                const dy = y - (node.y + node.height / 2);
                return Math.sqrt(dx * dx + dy * dy) <= 7;
            });
        }

        function getInputAt(x, y) {
            return nodes.find(node => {
                const dx = x - (node.x - 10);
                const dy = y - (node.y + node.height / 2);
                return Math.sqrt(dx * dx + dy * dy) <= 7;
            });
        }

        canvas.addEventListener("mousedown", (event) => {
            const { offsetX, offsetY } = event;
            const outputNode = getOutputAt(offsetX, offsetY);
            if (outputNode) {
                selectedOutput = outputNode;
                tempConnection = { x: outputNode.x + outputNode.width + 10, y: outputNode.y + outputNode.height / 2, endX: offsetX, endY: offsetY };
            } else {
                selectedNode = nodes.find(node => offsetX > node.x && offsetX < node.x + node.width && offsetY > node.y && offsetY < node.y + node.height);
                if (selectedNode) {
                    isDragging = true;
                }
            }
        });

        canvas.addEventListener("mousemove", (event) => {
            if (isDragging && selectedNode) {
                selectedNode.x = event.offsetX - selectedNode.width / 2;
                selectedNode.y = event.offsetY - selectedNode.height / 2;
                draw();
            } else if (tempConnection) {
                tempConnection.endX = event.offsetX;
                tempConnection.endY = event.offsetY;
                draw();
            }
        });

        canvas.addEventListener("mouseup", (event) => {
            if (isDragging) {
                isDragging = false;
                selectedNode = null;
            } else if (tempConnection) {
                const targetNode = getInputAt(event.offsetX, event.offsetY);
                if (targetNode && selectedOutput !== targetNode) {
                    connections.push({ from: selectedOutput, to: targetNode });
                }
                tempConnection = null;
                selectedOutput = null;
                draw();
            }
        });

        function addNode() {
            document.getElementById("nodeForm").style.display = "block";
        }

        document.getElementById("addNodeButton").addEventListener("click", addNode);

        document.getElementById("saveNodeButton").addEventListener("click", () => {
            const title = document.getElementById("nodeTitle").value;
            const newNode = {
                x: Math.random() * (canvas.width / scale - 100),
                y: Math.random() * (canvas.height / scale - 100),
                width: 80,
                height: 50,
                id: nodes.length + 1,
                title: title
            };
            
            const adTextForms = document.querySelectorAll(".container");
            const texts = [];
            adTextForms.forEach(form => {
                const speaker = form.querySelector("input").value;
                const text = form.querySelector("textarea").value;
                texts.push({ speaker, text });
                form.remove();
            });

            newNode.texts = texts


            const nodeValue = {
                title: title,
                texts: texts
            };


            allNodeValue[nodeValue.title] = nodeValue;

            console.log(allNodeValue);


            nodes.push(newNode);

            document.getElementById("nodeForm").style.display = "none";
            document.getElementById("nodeTitle").value = "";

            draw();
        });

        document.getElementById("addTextButton").addEventListener("click", () => {
            const adTextForm = document.createElement("div");
            adTextForm.className = "container";
            adTextForm.style.marginTop = "5px";

            const speakerDiv = document.createElement("div");
            const speakerInput = document.createElement("input");
            speakerInput.type = "text";
            speakerInput.placeholder = "speaker";
            speakerInput.style.border = "1px solid rgb(201, 201, 201)";
            speakerInput.style.borderRadius = "3px";
            speakerDiv.appendChild(speakerInput);

            const textDiv = document.createElement("div");
            const textarea = document.createElement("textarea");
            textarea.type = "text";
            textarea.placeholder = "Text dialog";
            textarea.style.border = "1px solid rgb(201, 201, 201)";
            textarea.style.borderRadius = "3px";
            textDiv.appendChild(textarea);

            adTextForm.appendChild(speakerDiv);
            adTextForm.appendChild(textDiv);

            document.getElementById("nodeForm").insertBefore(adTextForm, document.getElementById("btnForm"));
        });

    </script>
</body>

</html>